import{_ as t,c as o,o as a,ag as i}from"./chunks/framework.C_7JoTpM.js";const m=JSON.parse('{"title":"A* Algorithm","description":"","frontmatter":{},"headers":[],"relativePath":"week1/pole-it/AStarAlgorithm.md","filePath":"week1/pole-it/AStarAlgorithm.md"}'),l={name:"week1/pole-it/AStarAlgorithm.md"};function s(r,e,h,n,d,c){return a(),o("div",null,e[0]||(e[0]=[i('<h1 id="a-algorithm" tabindex="-1">A* Algorithm <a class="header-anchor" href="#a-algorithm" aria-label="Permalink to &quot;A* Algorithm&quot;">​</a></h1><h2 id="what-is-the-a-algorithm" tabindex="-1">What is the A* Algorithm? <a class="header-anchor" href="#what-is-the-a-algorithm" aria-label="Permalink to &quot;What is the A* Algorithm?&quot;">​</a></h2><p>The A* algorithm is a popular pathfinding and graph traversal algorithm. It is widely used in robotics and games to find the shortest path between two points, especially when there are obstacles.</p><h2 id="how-does-it-work" tabindex="-1">How Does It Work? <a class="header-anchor" href="#how-does-it-work" aria-label="Permalink to &quot;How Does It Work?&quot;">​</a></h2><p>A* uses a best-first search and finds the least-cost path from a start node to a goal node. It uses a cost function:</p><ul><li><strong>f(n) = g(n) + h(n)</strong><ul><li><strong>g(n):</strong> The cost to reach node <code>n</code> from the start.</li><li><strong>h(n):</strong> The estimated cost from node <code>n</code> to the goal (heuristic).</li></ul></li></ul><p>The algorithm explores paths that appear to be the most promising, based on the sum of the actual cost and the estimated cost.</p><h2 id="steps-of-the-algorithm" tabindex="-1">Steps of the Algorithm <a class="header-anchor" href="#steps-of-the-algorithm" aria-label="Permalink to &quot;Steps of the Algorithm&quot;">​</a></h2><ol><li>Add the start node to an open list.</li><li>Repeat: <ul><li>Pick the node with the lowest <code>f</code> value from the open list.</li><li>If this node is the goal, reconstruct the path and finish.</li><li>Move the node to the closed list.</li><li>For each neighbor: <ul><li>If it is not walkable or is in the closed list, skip it.</li><li>If it is not in the open list, add it and compute its <code>f</code>, <code>g</code>, and <code>h</code> values.</li><li>If it is already in the open list, check if this path to that node is better (lower <code>g</code> value). If so, update its parent and costs.</li></ul></li></ul></li></ol><h2 id="why-use-a" tabindex="-1">Why Use A*? <a class="header-anchor" href="#why-use-a" aria-label="Permalink to &quot;Why Use A*?&quot;">​</a></h2><ul><li>Finds the shortest path efficiently.</li><li>Can avoid obstacles.</li><li>Works well in grid-based maps like the robot&#39;s arena.</li></ul><h2 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h2><p>Suppose the robot needs to go from point A to point B in an arena with walls. The A* algorithm will calculate the best route, avoiding walls and minimizing the distance.</p><h2 id="in-the-collectorrobot-class" tabindex="-1">In the CollectorRobot Class <a class="header-anchor" href="#in-the-collectorrobot-class" aria-label="Permalink to &quot;In the CollectorRobot Class&quot;">​</a></h2><p>The CollectorRobot uses the A* algorithm to plan its movement in the arena, ensuring it can reach waste items or the sorter robot efficiently while avoiding obstacles.</p><hr><p>For more details, see this <a href="https://www.geeksforgeeks.org/a-search-algorithm/" target="_blank" rel="noreferrer">GeeksforGeeks article on A*</a>.</p>',17)]))}const g=t(l,[["render",s]]);export{m as __pageData,g as default};

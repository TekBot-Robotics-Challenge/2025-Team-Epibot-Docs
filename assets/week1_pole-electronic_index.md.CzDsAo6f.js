import{_ as n,c as t,o as s,ag as a,j as r}from"./chunks/framework.C_7JoTpM.js";const m=JSON.parse('{"title":"TEST INPUT: DOCUMENTATION","description":"","frontmatter":{},"headers":[],"relativePath":"week1/pole-electronic/index.md","filePath":"week1/pole-electronic/index.md"}'),o={name:"week1/pole-electronic/index.md"};function i(l,e,p,c,h,d){return s(),t("div",null,e[0]||(e[0]=[a(`<h1 id="test-input-documentation" tabindex="-1"><strong>TEST INPUT: DOCUMENTATION</strong> <a class="header-anchor" href="#test-input-documentation" aria-label="Permalink to &quot;__TEST INPUT: DOCUMENTATION__&quot;">​</a></h1><p>In this documentation:</p><ul><li><a href="#general-context">General context</a></li><li><a href="#part-1-description-of-components">PART 1: Description of components</a></li><li><a href="#part-2-assembly-of-components">PART 2: Assembly of components</a></li><li><a href="#part-3-the-arduino-code">PART 3: The Arduino Code</a></li><li><a href="#part-4-testing-the-project">PART 4: Testing the project</a></li><li><a href="#helpful-ressources-you-can-consult">Helpful ressources you can consult</a></li></ul><h2 id="general-context" tabindex="-1">General context <a class="header-anchor" href="#general-context" aria-label="Permalink to &quot;General context&quot;">​</a></h2><p>Understanding orientation in space, <strong>knowing what is left, right, up or down</strong>, is a fundamental skill acquired through our senses during childhood.</p><p>For robots, this spatial awareness must be replicated <strong>using sensors like gyroscopes and accelerometers</strong>. These devices convert physical data into electrical signals, enabling robots to measure velocity, rotation and orientation in space.</p><p>This test focuses on identifying and using a sensor that <strong>combines both the functions</strong> of a gyroscope and an accelerometer to determine spatial orientation and motion, which are essential for navigation and control.</p><h2 id="part-1-description-of-components" tabindex="-1">PART 1: Description of components <a class="header-anchor" href="#part-1-description-of-components" aria-label="Permalink to &quot;PART 1: Description of components&quot;">​</a></h2><h3 id="a-the-mpu-6050-gyroscope-and-accelerometer-in-one-sensor" tabindex="-1">a. The MPU-6050: gyroscope and accelerometer in one sensor <a class="header-anchor" href="#a-the-mpu-6050-gyroscope-and-accelerometer-in-one-sensor" aria-label="Permalink to &quot;a. The MPU-6050: gyroscope and accelerometer in one sensor&quot;">​</a></h3><p>The <a href="https://www.allelcoelec.com/blog/mpu-6050-in-action-practical-guide-to-setup%2Cconfiguration%2Cand-noise-management.html?srsltid=AfmBOooVL5CkBlAuw8WV0Yz7l7ZA2u8Ld6yBZFQf7kaTwiemNMmpUUey&amp;utm_source=chatgpt.com#8.%20MPU-6050-Based%20Motion%20Trajectory%20Calculation" target="_blank" rel="noreferrer">MPU-6050</a> is a sophisticated device that combines:</p><ul><li>a 3-axis <a href="https://en.wikipedia.org/wiki/Gyroscope" target="_blank" rel="noreferrer">gyroscope</a></li><li>a 3-axis <a href="https://en.wikipedia.org/wiki/Accelerometer" target="_blank" rel="noreferrer">accelerometer</a></li><li>a Digital Motion Processor (DMP)</li></ul><p>This effectively makes the MPU-6050 the world&#39;s first 6-axis motion processing unit. It measures pitch (lateral axis rotation), roll (longitudinal axis rotation) and yaw (vertical axis rotation), which are fundamental for determining an object&#39;s orientation along the x, y and z axes.</p><p>The MPU-6050 communicates with the <a href="https://en.wikipedia.org/wiki/Microcontroller" target="_blank" rel="noreferrer">Microcontroller Unit</a> (MCU) using the <a href="https://en.wikipedia.org/wiki/I%C2%B2C" target="_blank" rel="noreferrer">Inter-Integrated Circuit</a> (I2C) connection protocol through the Serial Clock Line (SCL) and Serial Data Line (SDA) wires, which lets the devices exchange information easily. This setup allows the MPU-6050 to measure the speed, the rotation and the orientation of an object, all of which help the robot understand how it&#39;s moving in space.</p><p align="center"><img src="https://github.com/user-attachments/assets/4bf5947f-d250-4168-9c4e-4eb1d2022695" width="500"></p><p>The MPU-6050 works by using tiny sensors inside it to detect movement and rotation <em>in three directions</em>. It can also be connected to an external compass to provide even more detailed motion tracking.</p><h4 id="the-gyroscope" tabindex="-1">The gyroscope <a class="header-anchor" href="#the-gyroscope" aria-label="Permalink to &quot;The gyroscope&quot;">​</a></h4><p>The <a href="https://en.wikipedia.org/wiki/Gyroscope" target="_blank" rel="noreferrer">gyroscope</a> in the MPU-6050 <em>measures rotation</em>. This sensor operates on the principles of angular momentum, maintaining its orientation via the gyroscopic effect. This fascinating phenomenon allows the measurement of rotation direction and angles by identifying deviations from an initial axis.</p><h4 id="the-accelerometer" tabindex="-1">The accelerometer <a class="header-anchor" href="#the-accelerometer" aria-label="Permalink to &quot;The accelerometer&quot;">​</a></h4><p>The <a href="https://en.wikipedia.org/wiki/Accelerometer" target="_blank" rel="noreferrer">accelerometer</a> in the MPU-6050 <em>measures acceleration</em>: how fast an object speeds up, slows down, or changes its direction. It uses the <a href="https://en.wikipedia.org/wiki/Piezoelectricity" target="_blank" rel="noreferrer">piezoelectric effect</a> to evaluate acceleration forces, detecting the electrical charge produced by a moving object. In other terms, it works by detecting tiny forces inside the sensor when it moves.</p><h4 id="the-digital-motion-processor-dmp" tabindex="-1">The Digital Motion Processor (DMP) <a class="header-anchor" href="#the-digital-motion-processor-dmp" aria-label="Permalink to &quot;The Digital Motion Processor (DMP)&quot;">​</a></h4><p>The Digital Motion Processor in the MPU-6050 <em>processes</em> the rotation data from the gyroscope and the movement data from the accelerometer through sophisticated algorithms such as <a href="https://en.wikipedia.org/wiki/Kalman_filter" target="_blank" rel="noreferrer">Kalman filtering</a>. The result is <a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation" target="_blank" rel="noreferrer">quaternions</a>, a mathematical representation that blends rotational and translational data for in-depth motion analysis. The DMP also takes a load off the main processor, making the whole system faster and more efficient.</p><h3 id="b-the-oled-screen-visualize-the-data" tabindex="-1">b. The OLED screen: Visualize the data <a class="header-anchor" href="#b-the-oled-screen-visualize-the-data" aria-label="Permalink to &quot;b. The OLED screen: Visualize the data&quot;">​</a></h3><p>The <strong>SSD1306</strong> is a popular and compact OLED display module used in a variety of projects to display text or graphics. It communicates with the microcontroller via the <em>I2C communication protocol</em> (just like the MPU-6050 sensor), making it easy to integrate.</p><p align="center"><img src="https://github.com/user-attachments/assets/4d858669-0e95-4ade-90b5-f548c9f1729f" width="500"></p><p>The SSD1306 is <strong>ideal</strong> for viewing the pitch, roll and yaw readings from the MPU-6050 sensor, with a simple, yet pleasing interface or menu. It also allows for real-time motion updates.</p><h3 id="c-the-arduino-uno-central-control-unit" tabindex="-1">c. The Arduino UNO: Central Control Unit <a class="header-anchor" href="#c-the-arduino-uno-central-control-unit" aria-label="Permalink to &quot;c. The Arduino UNO: Central Control Unit&quot;">​</a></h3><p>The <a href="https://docs.arduino.cc/hardware/uno-rev3/" target="_blank" rel="noreferrer">Arduino UNO</a> is a small electronic board that acts as the <strong>&quot;brain&quot;</strong> of the project. It can be programmed to control sensors, screens, motors, lights and much more. It acts as a basic computer that interacts with the physical world. These attributes of the Arduino make it perfect for this project, as it can read data from our MPU-6050 and output it on our SSD1306 screen while handling communication between all components using I2C.</p><p align="center"><img src="https://github.com/user-attachments/assets/3198e572-b41c-4c76-8e33-dbfeda0f17e9"></p><h3 id="d-creating-our-custom-power-supply" tabindex="-1">d. Creating our custom power supply <a class="header-anchor" href="#d-creating-our-custom-power-supply" aria-label="Permalink to &quot;d. Creating our custom power supply&quot;">​</a></h3><p>To further our study of the MPU-6050 sensor and to be able to test its functionning, we should build a small custom power supply that provides safe and stable voltage to all components. For that we will use the <strong>built-in tension regulator</strong> from the Arduino UNO board and a <strong>9V electric battery</strong>.</p><h4 id="here-s-a-synoptic-diagram-to-better-illustrate-it-all" tabindex="-1">Here&#39;s a synoptic diagram to better illustrate it all: <a class="header-anchor" href="#here-s-a-synoptic-diagram-to-better-illustrate-it-all" aria-label="Permalink to &quot;Here&#39;s a synoptic diagram to better illustrate it all:&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>                        +-----------------+</span></span>
<span class="line"><span>                        |   9V Battery    |</span></span>
<span class="line"><span>                        |                 |</span></span>
<span class="line"><span>                        |   +        GND  |</span></span>
<span class="line"><span>                        +---|---------|---+</span></span>
<span class="line"><span>                            |         |</span></span>
<span class="line"><span>                           VIN       GND</span></span>
<span class="line"><span>                            |         |</span></span>
<span class="line"><span>                        +---+---------+---+</span></span>
<span class="line"><span>                        |   Arduino Uno   |</span></span>
<span class="line"><span>                        |   (built-in     |</span></span>
<span class="line"><span>                        |   regulator)    |</span></span>
<span class="line"><span>                        +---+---------+---+</span></span>
<span class="line"><span>                                 |        </span></span>
<span class="line"><span>                            [5V output]</span></span>
<span class="line"><span>                                 |</span></span>
<span class="line"><span>                                 | </span></span>
<span class="line"><span>                        +--------+--------+</span></span>
<span class="line"><span>                        |    Modules      |</span></span>
<span class="line"><span>                        |   (OLED, MPU)   |</span></span>
<span class="line"><span>                        +-----------------+</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="part-2-assembly-of-components" tabindex="-1">PART 2: Assembly of components <a class="header-anchor" href="#part-2-assembly-of-components" aria-label="Permalink to &quot;PART 2: Assembly of components&quot;">​</a></h2><p>The following images showcase the connections to be made between the SSD1306, the MPU-6050 and the Arduino UNO.</p><p>For illustration purposes and to get a deeper overview of the connection made in beatween the components, we made a <a href="https://docs.kicad.org/" target="_blank" rel="noreferrer">KiCad</a> schematic (download the KiCad EDA <a href="https://www.kicad.org/" target="_blank" rel="noreferrer">here</a>). Here&#39;s our schematic:</p><p align="center"><img src="https://github.com/user-attachments/assets/43aaf30d-b976-4e55-bf47-786b4c8feff7" width="800"></p><p>All components are connected using the <strong>I2C bus</strong>, a synchronous serial communication protocol. The <strong>MPU6050</strong> sensor and the <strong>OLED screen (SSD1306)</strong> are both placed on a breadboard, which serves as a convenient platform for making electrical connections without soldering. Both devices are wired <strong>in parallel</strong> to the same SDA and SCL pins of the Arduino, meaning their respective SDA and SCL pins are linked together on the <a href="https://en.wikipedia.org/wiki/Breadboard" target="_blank" rel="noreferrer">breadboard</a> and then connected to the Arduino’s SDA (A4) and SCL (A5) pins. The I2C protocol allows these devices to <strong>share the same communication lines</strong> by assigning each a <strong>unique address</strong> (typically 0x3C for the SSD1306 and 0x68 for the MPU-6050), enabling the Arduino to communicate with each device individually over the shared bus. This whole setup is powered by a <strong>9V electric battery</strong> connected to the Jack port of the Arduino UNO board, port through which the Arduino UNO, thanks to it&#39;s built-in tension regulator, is able to receive and reduce the tension to 5V to respect each module&#39;s minimal requirement of 3.3 V and maximum tension of 5V.</p><h4 id="connecting-the-ssd1306-to-the-arduino-uno" tabindex="-1">Connecting the SSD1306 to the Arduino UNO <a class="header-anchor" href="#connecting-the-ssd1306-to-the-arduino-uno" aria-label="Permalink to &quot;Connecting the SSD1306 to the Arduino UNO&quot;">​</a></h4><p align="center"><img src="https://github.com/user-attachments/assets/d6634e37-e542-4dfd-8961-57af85efb327" width="600"></p><h4 id="connecting-the-mpu-6050-to-the-arduino-uno" tabindex="-1">Connecting the MPU-6050 to the Arduino UNO <a class="header-anchor" href="#connecting-the-mpu-6050-to-the-arduino-uno" aria-label="Permalink to &quot;Connecting the MPU-6050 to the Arduino UNO&quot;">​</a></h4><p align="center"><img src="https://github.com/user-attachments/assets/24712601-d2ee-4b3e-91b5-27eb747b680c" width="600"></p><h2 id="part-3-the-arduino-code" tabindex="-1">PART 3: The Arduino code <a class="header-anchor" href="#part-3-the-arduino-code" aria-label="Permalink to &quot;PART 3: The Arduino code&quot;">​</a></h2><p>After the wiring is done, we need to connect our Arduino UNO board to a computer through USB to program it using our Arduino Code.</p><p>Download the Arduino IDE using this <a href="https://www.arduino.cc/" target="_blank" rel="noreferrer">link</a>. It&#39;s a software that will allow you to run and upload your code to the Arduino UNO board through a USB wire. Once the installation is done, we can set up by installing the necessary libraries via the <strong>Library Manager</strong> in the Arduino IDE (<em>make sure that you also install their dependencies when prompted to</em>). We will need the following Arduino libraries:</p><ul><li><p>The <strong>Wire</strong> library for I2C communication (required for the MPU-6050 and the SSD1306)</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;Wire.h&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p>The <strong>Adafruit SSD1306</strong> library for managing our SSD1306 module</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;Adafruit_SSD1306.h&gt;</span></span>
<span class="line"><span>#include &lt;Adafruit_GFX.h&gt;</span><span>  // Required for graphics</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p>The <strong>Adafruit MPU6050</strong> library for managing</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;Adafruit_MPU6050.h&gt;</span></span>
<span class="line"><span>#include &lt;Adafruit_Sensor.h&gt;</span><span>  // Required for sensor data structures</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul><p>Next, in the <strong>setup()</strong> function, we call <code>Serial.begin(115200);</code> to start the <em>serial monitor</em> at 115200 <a href="https://en.wikipedia.org/wiki/Baud" target="_blank" rel="noreferrer">bauds</a>, and <code>Wire.begin();</code> to start the I2C bus.</p><h3 id="fetching-data-from-the-mpu-6050-sensor" tabindex="-1">Fetching data from the MPU-6050 sensor <a class="header-anchor" href="#fetching-data-from-the-mpu-6050-sensor" aria-label="Permalink to &quot;Fetching data from the MPU-6050 sensor&quot;">​</a></h3><p>We first need to initialize the MPU-6050 sensor. For that, in the <strong>setup()</strong> function, we call <code>mpu.initialize();</code>.</p><p>In the <strong>loop()</strong> function, we do this for reading raw data from our MPU-6050 sensor:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int16_t ax, ay, az;</span></span>
<span class="line"><span>mpu.getAcceleration(&amp;ax, &amp;ay, &amp;az);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>This fetched data represents the object&#39;s acceleration following the X, Y and Z axes. We will then need to perform a conversion of this data to <strong>m/s²</strong>. From that, we can then estimate the <strong>total acceleration</strong> and <strong>rotation</strong> by using some trigonometrical formulas.</p><h3 id="outputting-the-readings-onto-the-ssd1306-screen" tabindex="-1">Outputting the readings onto the SSD1306 screen <a class="header-anchor" href="#outputting-the-readings-onto-the-ssd1306-screen" aria-label="Permalink to &quot;Outputting the readings onto the SSD1306 screen&quot;">​</a></h3><p>We first need to declare our SSD1306 display.</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#define SCREEN_WIDTH 128</span><span>           // in pixels</span></span>
<span class="line"><span>#define SCREEN_HEIGHT 64</span><span>           // in pixels</span></span>
<span class="line"><span>#define SCREEN_ADDRESS 0x3C</span><span>        // Standard I2C address for SSD1306</span></span>
<span class="line"><span>#define OLED_RESET -1</span><span>              // No reset pin used with I2C</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ---------- Display declaration ----------</span></span>
<span class="line"><span>Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>We then initialize the SSD1306 OLED module in the <strong>setup()</strong> function by doing: <code>display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)</code>.</p><p>Although optional, we decided to display our school&#39;s logo at the screen&#39;s startup. You can choose to also display an image at startup. For that, you will need to convert your image to the 1-bit (monochrome) format employed by the SSD1306. You can use this <a href="https://javl.github.io/image2cpp/" target="_blank" rel="noreferrer">tool</a> to generate a 1-bit map for your image. You will only need to upload your image file and adjust the settings. You can then use <code>display.drawBitmap(0, 0, myLogo, 128, 64, WHITE);</code> to draw your image from your generated 1-bit map to the screen.</p><p>To print the readings from our sensor to the screen, we use <code>display.clearDisplay();</code> to first clear the screen buffer, then <code>display.print()</code> to write to the screen and finally <code>display.display();</code> to display everything.</p><h2 id="part-4-testing-the-project" tabindex="-1">PART 4: Testing the project <a class="header-anchor" href="#part-4-testing-the-project" aria-label="Permalink to &quot;PART 4: Testing the project&quot;">​</a></h2><p>Check the wiring again first, place the setup flat in the palm of your hand.</p><ul><li>To test the pitch, tilt your hand up and down (like a head nod).</li><li>To test the roll, tilt your hand sideways (like moving your head left and right).</li><li>To test the yaw, spin your hand in place clockwise or counter-clockwise while keeping it level.</li></ul><h4 id="here-s-a-demonstration-video" tabindex="-1">Here&#39;s a demonstration video <a class="header-anchor" href="#here-s-a-demonstration-video" aria-label="Permalink to &quot;Here&#39;s a demonstration video&quot;">​</a></h4>`,61),r("iframe",{width:"auto",height:"315",src:"https://youtube.com/embed/SwCvNdGykKs?feature=share",frameborder:"0",allowfullscreen:""},null,-1),a('<h2 id="helpful-ressources-you-can-consult" tabindex="-1">Helpful ressources you can consult <a class="header-anchor" href="#helpful-ressources-you-can-consult" aria-label="Permalink to &quot;Helpful ressources you can consult&quot;">​</a></h2><ul><li><a href="https://www.kicad.org/" target="_blank" rel="noreferrer">Download KiCad</a></li><li><a href="https://www.arduino.cc/" target="_blank" rel="noreferrer">Download the Arduino IDE</a></li><li><a href="https://lastminuteengineers.com/mpu6050-accel-gyro-arduino-tutorial/" target="_blank" rel="noreferrer">https://lastminuteengineers.com/mpu6050-accel-gyro-arduino-tutorial/</a></li><li><a href="https://lastminuteengineers.com/oled-display-arduino-tutorial/" target="_blank" rel="noreferrer">https://lastminuteengineers.com/oled-display-arduino-tutorial/</a></li><li><a href="https://en.wikipedia.org/wiki/" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/</a></li><li><a href="https://www.instructables.com" target="_blank" rel="noreferrer">https://www.instructables.com</a></li><li><a href="https://docs.arduino.cc/" target="_blank" rel="noreferrer">https://docs.arduino.cc/</a></li><li><a href="https://www.geeksforgeeks.org" target="_blank" rel="noreferrer">https://www.geeksforgeeks.org</a></li></ul>',2)]))}const g=n(o,[["render",i]]);export{m as __pageData,g as default};
